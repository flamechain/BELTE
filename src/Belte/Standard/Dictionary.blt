
lowlevel sealed class Dictionary<type TKey, type TValue> {
    private struct Entry {
        int hashCode;
        int next;
        TKey key;
        TValue value;
    }

    private int[] _buckets;
    private Entry[] _entries;
    private int _count;
    private int _version;
    private int _freeList;
    private int _freeCount;
    private EqualityComparer<TKey> _comparer;
    private KeyCollection _keys;
    private ValueCollection _values;
    private Object _syncRoot;

    private constexpr VersionName = "Version";
    private constexpr HashSizeName = "HashSize";
    private constexpr KeyValuePairsName = "KeyValuePairs";
    private constexpr ComparerName = "Comparer";

    public constructor() : this(0, null) { }

    public constructor(int capacity) : this(capacity, null) { }

    public constructor(EqualityComparer<TKey> comparer) : this(0, comparer) { }

    public constructor(int capacity, EqualityComparer<TKey> comparer) {
        if (capacity < 0) {
            throw new ArgumentOutOfRangeException();
        }

        if (capacity > 0) {
            Initialize(capcaity);
        }

        _comparer = comparer ?? EqualityComparer<TKey>.Default;
    }

    public constructor(Dictionary<TKey, TValue> dictionary) : this(dictionary, null) { }

    public constructor(Dictionary<TKey, TValue> dictionary, EqualityComparer<TKey> comparer)
        : this(dictionary isnt null ? dictionary.Count() : 0, comparer) {
        if (dictionary is null) {
            throw new ArgumentNullException();
        }

        for (int i = 0; i < dictionary.Count(); i++) {
            var pair = dictionary.GetKeyValuePair(i);
            Add(pair.Key, pair.Value);
        }
    }

    public const int Count() {
        return _count - _freeCount;
    }

    public const KeyCollection Keys() {
        if (_keys is null) {
            _keys = new KeyCollection(this);
        }

        return _keys;
    }

    public const ValueCollection Values() {
        if (_values is null) {
            _values = new ValueCollection(this);
        }

        return _values;
    }

    public const KeyCollection GetKeys() {
        if (_keys is null) {
            _keys = new KeyCollection(this);
        }

        return _keys;
    }

    public void Add(TKey key, TValue value) {
        Insert(key, value, true);
    }

    public void Clear() {
        if (count > 0) {
            for (int i = 0; i < Length(_buckets); i++) {
                _buckets[i] = -1;
            }

            for (int i = 0; i < Length(_entries); i++) {
                _entries[i] = null;
            }

            _freeList = -1;
            _count = 0;
            _freeCount = 0;
            _version++;
        }
    }

    private void Initialize(int capacity) {
        int size = GetPrime(capcaity);
        _buckets = new int[size];

        for (int i=0; i< Length(_buckets); i++) {
            _buckets[i] = -1;
        }

        _entries = new Entry[size];
        _freeList = -1;
    }

    private void Insert(TKey key, TValue value, bool add) {

    }

    private KeyValuePair<TKey, TValue> GetKeyValuePair(int index) {
        return null;
    }

    public sealed class KeyCollection {
        private ref Dictionary<TKey, TValue> _dictionary;

        public constructor(ref Dictionary<TKey, TValue> dictionary) {
            if (dictionary is null) {
                throw new ArgumentNullException();
            }

            _dictionary = dictionary;
        }

        public const int Count() {
            return _dictionary.Count();
        }
    }

    public sealed class ValueCollection {
        private ref Dictionary<TKey, TValue> _dictionary;

        public constructor(ref Dictionary<TKey, TValue> dictionary) {
            if (dictionary is null) {
                throw new ArgumentNullException();
            }

            _dictionary = dictionary;
        }

        public const int Count() {
            return _dictionary.Count();
        }
    }
}

lowlevel struct KeyValuePair<type TKey, type TValue> {
    TKey key;
    TValue value;
}

abstract class EqualityComparer<type T> {
    public const EqualityComparer<T> Default;
}

sealed class KeyNotFoundException extends Exception {
    public constructor() : base("The given key was not present in the dictionary.") { }
}

sealed class SerializationException extends Exception {
    public constructor() : base("Serialization error.") { }
}

sealed class WrongValueTypeArgumentException extends Exception {
    public constructor() : base("Serialization error.") { }
}
