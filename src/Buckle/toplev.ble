/* For testing the language syntax to make sure it has everything you need most the time */
include System.Stdout;

#define SUCCESS_EXIT 0

namespace toplev {

enum SyntaxType {
    NumberToken,
    WhitespaceToken,
    PlusToken,
    MinusToken,
    AsteriskToken,
    SolidusToken,
    LeftParenToken,
    RightParenToken,
    BadToken,
    EOFToken,
    NumberExpression,
    BinaryExpression,
}

class Lexer {
private:

    const string text_;
    int pos_;

    string<1> Current {
        get {
            if (pos_ >= text_.length) return "\0";
            return text_[pos_];
        }
    }

    void Advance() { pos_++; }

public:

    Lexer(string text) : text_(text) {}

    SyntaxToken Next() {
        if (pos_ >= text_.length)
            return SyntaxToken(SyntaxType.EOFToken, pos_, "\0", null);

        if (Current.IsNum()) {
            int start = pos_;

            while (Current.IsNum()) Advance();

            int len = pos_ - start;
            string text = text_.Substring(start, len);
            int value = text.ToInt();

            return SyntaxToken(SyntaxType.NumberToken, start, text, value);
        } else if (Current.IsWhitespace()) {
            int start = pos_;

            while (Current.IsWhitespace()) Advance();

            int len = pos_ - start;
            string text = text_.Substring(start, len);

            return SyntaxToken(SyntaxType.WhitespaceToken, start, text, null);
        } else if (Current == "+") {
            return SyntaxToken(SyntaxType.PlusToken, pos_++, "+", null);
        } else if (Current == "-") {
            return SyntaxToken(SyntaxType.MinusToken, pos_++, "-", null);
        } else if (Current == "*") {
            return SyntaxToken(SyntaxType.AsteriskToken, pos_++, "*", null);
        } else if (Current == "/") {
            return SyntaxToken(SyntaxType.SolidusToken, pos_++, "/", null);
        } else if (Current == "(") {
            return SyntaxToken(SyntaxType.OpenParenToken, pos_++, "(", null);
        } else if (Current == ")") {
            return SyntaxToken(SyntaxType.OpenParenToken, pos_++, ")", null);
        }

        return SyntaxToken(SyntaxToken.BadToken, pos_++, text_.Substring(pos_-1,1), null);
    }

}

class Parser {
private:

    SyntaxToken[] tokens_;

    SyntaxToken Peek(int offset) {
        int index = pos_ + offset;
        if (index >= tokens_.length) return tokens_[-1];
        return tokens_[index];
    }

    SyntaxToken Current => Peek(0);

public:

    Parser(string text) {
        Lexer lexer = Lexer(text);
        SyntaxToken token;

        while (token.Type != SyntaxType.EOFToken) {
            token = lexer.Next();

            if (token.Type != SyntaxType.WhitespaceToken &&
                token.Type != SyntaxType.BadToken) {
                tokens_.Append(token);
            }
        }
    }

    ExpressionSyntax Parse() {

    }

}

class SyntaxToken {
public:

    SyntaxType Type;
    int Pos;
    string Text;
    object Value;

    SyntaxToken(SyntaxType _type, int _pos, string _text, int _val) {
        Type = _type;
        Pos = _pos;
        Text = _text;
        Value = _value;
    }

}

abstract class SyntaxNode {
public:

    SyntaxType Type { get; }

}

abstract class ExpressionSyntax : SyntaxNode {
}

sealed class NumberExpressionSyntax : ExpressionSyntax {
public:

    const override SyntaxType Type = SyntaxType.NumberExpression;
    SyntaxToken Number { get; }

    NumberExpressionSyntax(SyntaxToken number) {
        Number = number;
    }

}

sealed class BinaryExpressionSyntax : ExpressionSyntax {
public:

    ExpressionSyntax Left;
    SyntaxToken Op;
    ExpressionSyntax Right;
    const override SyntaxType Type = SyntaxType.BinaryExpression;

    BinaryExpressionSyntax(ExpressionSyntax left, SyntaxToken op, ExpressionSyntax right) {
        Left = left;
        Op = op;
        Right = right;
    }

}

int main() {
    int error = SUCCESS_EXIT;

    while (true) {
        string line = Stdout.input("> ");
        if (line.IsNullOrWhitespace()) return;

        Lexer lexer = Lexer(line);
        while (true) {
            auto token = lexer.Next();

            if (token.Type == SyntaxType.EOFToken) break;

            Stdout.print($"{token.Type}: '{token.Text}'", end="");
            if (token.Value != null)
                Stdout.print($" {token.Value}");

            Stdout.print();
        }
    }

    return error;
}

}
// >15 lines less than C# version (using more newlines than C# version); 72 lines less than C++ version (same formatting)