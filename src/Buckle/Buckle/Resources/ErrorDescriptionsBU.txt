$BU0000
If you see this error code, that means that there was a fatal error in the
compiler that prevented it from completing compilation. This is NOT a user
error, but rather a bug that should be reported. Currently, the best way to
report bugs is directly on the issues tab on GitHub.

If the problem is preventing further development, try downgrading Buckle to the
previous stable patch version. If the problem persists, make sure to create an
issue on GitHub (though we at Belte Industries would appreciate an issue
report nonetheless).

You can use the following link to create an issue:
https://github.com/ryanwilsond/belte/issues/new?assignees=&labels=&template=bug_report.md&title=
$BU0001
The compiler produces this warning if it can tell that an expression will always
result in the same value. Not all expressions that have a constant value will be
found by the compiler, but most simple ones will.

For example:

```
if (2 > 0) { } // 2 > 0 is always true, so this warning is produced
```
$BU0002
The compiler produces this warning if it detected that a value may be null
during a deference/member accession. Note that the compiler cannot catch every
null deference case, especially relating to called code where code analysis is
not possible. You can prevent this warning by using the null assert (`!`)
operator.

For example:

```
struct MyStruct {
    int myMember;
}

void MyFunction(MyStruct myParameter) {
    myParameter.myMember = 3; // Warning is produced here
    myParameter!.myMember = 3; // But not here
}
```
$BU0003
The compiler produces this error when it either ca not find a reference, or it is
the wrong file type. This usually means that a reference specified on the command
line is in a different location.

For example:

```
$ buckle --ref=some/fake/reference.dll // Correct format, but does not exist
```
$BU0004
When the compiler fails to parse a literal it produces this error. Currently,
this error will only come up in place of runtime overflow or underflow
exceptions.

For example:

```
int myInt = 9999999999; // Exceeds integer limit, cannot parse
```
$BU0005
When the compiler is given an unknown character when scanning the input files,
it produces this error. Thus this is a user syntax error.

For example:

```
@ // The compiler does not currently handle this character
```
$BU0006
When the compiler expects a certain piece of text and does not find it, this
error is produced. This error comes in three forms:

- Unexpected token
- Unexpected token, expected another token instead
- Expected a token at the end of the input

In all of these cases, if this error is raised the user made a syntax error.

For example:
```
if (true { } // The compiler expected a closing parenthesis before the open bracket
```
$BU0007
Some casts are implied, but others must be explicitly specified. When an
explicit cast is not specified explicitly, this error is produced.

For example:

```
decimal myDecimal = 4; // Implicit cast from integer to decimal, allowed
int myInt = 3.4; // Explicit cast from decimal to integer, produces this error
```

When possible the compiler will suggest how to make the cast explicit. If no
explicit cast is possible either, error BU0020 is used instead.
$BU0008
When a unary operator is used with unsupported types, this error is produced.

For example:

```
int myInt = ~4; // `~` is allowed with integer types
decimal myDecimal = ~3.4; // But not for decimal types
```

A possible fix to this error may be inserting a cast.
$BU0009
When the compiler fails to resolve a built-in type when assembling, it produces
this error. This happens when it cannot find the built-in type. If this happens
the build is probably broken.

If this problem persists, you can report an issue on the Belte GitHub:
https://github.com/ryanwilsond/belte/issues/new?assignees=&labels=&template=bug_report.md&title=
$BU0010
When the compiler fails to resolve a built-in type when assembling, it produces
this error. This happens when it finds multiple types for a singular built-in
type. If this happens the build is probably broken.

If this problem persists, you can report an issue on the Belte GitHub:
https://github.com/ryanwilsond/belte/issues/new?assignees=&labels=&template=bug_report.md&title=
$BU0011
When a binary operator is used with unsupported types, this error is produced.

For example:

```
int myInt = 3 + 4; // `+` is allowed with two integers
bool myBool = true + 3; // But not for a boolean and an integer
```

A possible fix to this error may be inserting a cast.
$BU0012
Without a `Main` function, the compiler will run files top-down. However when
compiling multiple files, it becomes ambiguous which file to run first.
Because of this, only one file can contain global statements.

If this becomes a problem, consider reworking your project to use an explicit
entry point such as `Main`, or specify one with the '--entry' command-line
option.
$BU0013
When a function is declared with multiple parameters of the same name, it
becomes ambiguous when referencing parameters. Because of this, each parameter
must have a unique name, even if they are different types. This also makes the
code easier to read inside the function body.

For example:

```
void MyFunction(int myParam, bool myParam) { } // Not allowed because both parameters have the same name
```
$BU0014
`Main` can only return void or an integer. If a `Main` function is declared
with any other return type this error is produced.

For example:

```
string Main() {
    return "Hello, world!";
} // `Main` cannot return strings
```

This is a callback to how older languages like C handle their entry points with
the command line. If you are making a library with no entry point, this error
will not come up.
$BU0015
When the compiler fails to resolve certain functions when assembling, it
produces this error. This happens when the function cannot be found. If this
happens the build is probably broken.

If this problem persists, you can report an issue on the Belte GitHub:
https://github.com/ryanwilsond/belte/issues/new?assignees=&labels=&template=bug_report.md&title=
$BU0016
When a `Main` function is not declared, files are run top-down. However if a
`Main` function is declared, global statements are not allowed as it becomes
ambiguous about where to start execution.

For example:

```
PrintLine("Hello, world!"); // Not allowed, because `Main` is where execution starts

void Main() { }
```
$BU0017
When a symbol is referenced and it cannot be found, the compiler produces this
error. This is most likely the result of a typo or scoping issue.

For example:

```
int myInt = 3 + myOtherInt; // `myOtherInt` was never declared, so this is not allowed
```
$BU0018
Functions in the same scope have to have unique names (unless you are
overloading). When an attempt is made to declare a function with a name already
used (and the parameter list is the same), the compiler produces this error.
This is to make sure there is no ambiguity when calling functions. Other
overload-related errors such as BU0057 and BU0058 will be used with overloaded
functions instead.

For example:

```
void MyFunction() { } // `MyFunction` has not been declared in this scope, allowed

void MyFunction() { } // `MyFunction` has already been declared, not allowed
```
$BU0019
To prevent undefined behavior, all functions must return in all scenarios if
they have a non-void return type. The compiler checks this, and raises an error
if any code path does not return.

For example:

```
int MyFunction(int myParam) {
    if (myParam > 3)
        return myParam + 1;
    // If `myParam` is not greater than 3 this function does not return, not allowed
}
```

The compiler uses graph analysis on the code to figure out what paths do not
return. If you believe there is an issue, report one:
https://github.com/ryanwilsond/belte/issues/new?assignees=&labels=&template=bug_report.md&title=
$BU0020
If a cast is not specified between two types, the compiler produces this error.

For example:

```
int[] myCollection = (int[])"test"; // Cannot cast from string to integer collection
```

User-defined types must create their own casting rules.
$BU0021
Variables in the same scope have to have unique names. When an attempt is made
to declare a variable with a name already used, the compiler produces this
error. This is to make sure there is no ambiguity when referencing variables.

For example:

```
int myVar; // `myVar` has not been declared in this scope, allowed
int myVar; // `myVar` has already been declared, not allowed
```

However, if they are in separate scopes this is allowed.

For example:

```
int myVar;

void MyFunction() {
    int myVar; // `myVar` has not been declared in this scope, allowed
}
```

In this case, the most nested declaration gets priority in the most nested
scope. If `myVar` was referenced in `MyFunction` it would not use the outer
declaration, but rather the one nested inside `MyFunction`. This applies even if
the variables have different types. This is referred to as shadowing and is not
always allowed in nested block statements.
$BU0022
Constants can only be defined once, when they are declared. This means that you
cannot change their value after their initial definition. When an attempt is
made to redefine a constant, the compiler produces this error.

For example:

```
const int myConst = 4; // Initial definition, allowed and required
myConst = 5; // Redefinition, not allowed
```
$BU0023
Because of the way if-statements are parsed, they can become ambiguous. The
compiler produces this error to try and prevent some ambiguity.

For example:

```
if (true)
    if (true) ;
    else ;
```

This could be written as:

```
if (true)
    if (true) ;
else ;
```

Because whitespace is ignored by the compiler, these do the same thing. However,
they appear like they should execute differently from each other. In the first
example, the else clause seems to belong to the inner if-statement, however, in
the second example, it seems to belong to the outer if-statement.

Whenever there is an if-statement that contains an if-statement instead of a
block-statement for its body, and the inner if-statement has an else-clause
without using blocks, the compiler produces this error.
$BU0024
Expressions resulting in no value by using `void` cannot be put in place of
expressions expecting a value.

For example:

```
void MyFunction() { }

int myInt = MyFunction(); // `MyFunction` has no return value, and an initializer must have a value or be `null`
```
$BU0025
Indexing allows retrieving elements from a collection. However, indexing is only
allowed on collection types or user-defined types that support explicitly
support it. The compiler produces this error when indexing is used on any other
type.

For example:

```
int[] myCollection = {1, 2, 3};
int myInt = myCollection[2]; // `myCollection` is a collection type, so this is allowed
int mySecondInt = myInt[1]; // `myInt` is not a collection type, so this is not allowed
```
$BU0026
When the compiler detects unreachable code, it will produce this warning. This
is not an error because the compiler will continue the compilation process,
removing the unreachable code from the assembly.

For example:

```
if (true) {
    int myInt = 2;
} else {
    int myInt = 3; // True is always true, so this else-clause can never execute
}
```

It is usually bad practice to have unreachable code, but it is allowed as in
some cases it is helpful temporarily.
$BU0027
Every string is started with a double quote and ended the same way. If the
ending quote is missing, the compiler does not know when the string ends. In
that case, this error is produced.

For example:

```
string myString = "Hello, world!
int myInt = 2; // The string was never terminated, so an error is produced
```

This error assumes that multi-line strings are not allowed, and they are not
currently.
$BU0028
A function must have a declaration, so when a function without a declaration is
called, the compiler does not know what function is being referenced. In this
case, the compiler produces this error.

For example:

```
int myInt = MyFunction(); // `MyFunction` does not exist in this scope, not allowed
```

This error is usually temporary when implementing new functions, or the result
of a typo or scoping issue.
$BU0029
When calling a function, there must be the correct number of arguments provided
so the function can safely assume it can use the data it requests. If the number
of arguments provided in a function call does not match the function signature,
this error is raised.

For example:

```
int Add(int a, int b) {
    return a + b;
}

Add(1, 2, 3); // Too many arguments, incorrect
Add(1); // Too few arguments, incorrect
Add(1, 2); // Correct
```

This only applies to required parameters. Optional parameters, are optional, and
missing them would not raise this error. If there is a required parameter that
you do not want to pass, you can pass null (assuming it is a nullable
parameter), or use the shorthand implicit null argument syntax:

```
Add(1,);
// Would be the same as
Add(1, null);
```

Or even:

```
Add(,2);
// Would be the same as
Add(null, 2);
```
$BU0030
Similar to functions, variables, fields, and constants, structure types
(structs) cannot have more than one definition in a single scope. This is so
there is no ambiguity when referencing a structure.

For example:

```
struct MyStruct { // First definition, allowed
    int myMember;
}

struct MyStruct { // `MyStruct` was already defined, not allowed
    bool myOtherMember;
}
```

Even though the two definitions are different, they use the same identifier so
the second one is marked as an error.
$BU0031
When applying attributes to a type, you can specify any number of them. If there
are duplicate attributes, however, the compiler will raise this error. Even
though the compiler could figure out the intended meaning, it would be poorly
written code and possibly a mistake or oversight. Because of this, the compiler
does not allow duplicate attributes.

For example:

```
[NotNull]int myVar = 3; // Allowed
[NotNull, NotNull]int myVar = 3; // `NotNull` was duplicated, not allowed
```
$BU0032
Only methods, functions, and constructors are called objects. This is because
they have a body that can be run. Variables, constants, and other similar
objects only store data, they do not act on that data themselves. Hence, they
cannot be called as a function can. If it is attempted to call a variable,
field, constant, or indexer this error is raised.

For example:

```
void MyFunction() { }

int myInt = 3;

MyFunction(); // `MyFunction` is a function, allowed

myInt(); // `myInt` is a variable (cannot be called), not allowed
```
$BU0033
In a programming language, there are multiple grammatical components, such as
statements and expressions. Statements represent a complete thought, while
expressions only carry out a singular action. Some examples of statements are if
statements, try statements, block statements, etc. Some examples of expressions
are assignment expressions, variable declaration expressions, binary
expressions, etc.

Some expressions can be used as statements, such as assignment expressions.
When these expressions are used as statements, they are expression statements.

For example:

```
int myInt = 3; // This is an expression statement
myInt = 5; // This is an expression statement
```

Not all expressions can be used as statements, however. If an expression that
cannot be used as a statement is attempted to be used as a statement this error
is raised.

For example:

```
int myInt = 3; // This is an allowed expression statement
4 + 7; // This is not an allowed expression statement
```

For a full list of allowed expression statements, visit the Belte docs.
$BU0034
Belte is a statically typed language, so all variables, parameters, etc. need
a type associated with them at compile time. If a type is used that the compiler
is unaware of, this error is raised.

For example:

```
int myInt; // `int` is a known type, allowed
char myChar; // `char` is NOT a known type, not allowed
```
$BU0035
Break and continue statements are used to manipulate the running of a loop. That
is their only purpose, thus outside of a loop, they are invalid. This error is
raised if a break or continue statement is used outside of a loop.

For example:

```
while (true) {
    break; // Inside a while loop, allowed
}

break; // Not inside any loop, not allowed
```
$BU0036
Return statements are used to exit from a function or method. That is their only
purpose, in addition to returning values. Outside of a function or method,
return statements are invalid. This error is raised if a return statement is
used outside of a function or method.

For example:

```
int Main() {
    return 3; // Inside of a function, allowed
}

return 4; // Outside of a function or method, not allowed
```

The only exception to this rule is when a file is being run with global
statements. In that case, the return signals the end of the entire program.
$BU0037
Some functions are procedures, functions that do not return a value. In Belte
this is indicated by replacing the return type of a function with the `void`
keyword. If it is attempted to return a value in a void function, this error is
raised.

For example:

```
void MyFunction() {
    return; // Normal return in void function, allowed
}

void MyOtherFunction() {
    return 3; // Returning a value in a void function, not allowed
}
```
$BU0038
Some functions return values. If a function is indicated to return a value, it
must always return a value (or lack thereof using `null`). If a return statement
is used without a value in one of these functions, this error is raised.

For example:

```
int MyFunction() {
    return 1; // Returning a value when expected, allowed
}

int MyOtherFunction() {
    return; // Not returning a value when a value is expected, not allowed
}
```
$BU0039
Functions, methods, and constructors are callable objects. If one of these it
attempted to be used as a variable, this error is raised.

For example:

```
void MyFunction() { }

MyFunction(); // Calling a function, allowed

MyFunction = 3; // Treating a function as a variable, not allowed
```

This error is fairly general, and will be raised in any expression attempting
to use a function as a variable, including (but not limited to): binary, unary,
postfix, prefix, index, and assignment expressions.
$BU0040
In Belte, you can have the compiler guess the type of a variable by replacing
any type with the `var` keyword. (Note: this only applies to variables, not
parameters, return types, etc.) Because the compiler uses the declaration
initializer to guess the variable type, it is required to have an initializer
when using the `var` keyword. Otherwise, this error is raised.

For example:

```
var myInt = 3; // The compiler can figure out that `myInt` is an integer by the initializer, allowed
var myString; // The compiler has nothing to base the type on, not allowed
```

In dynamically typed languages this would probably be allowed, but because Belte
is statically typed it must know the type immediately, so this is not allowed.

The only solution to this error is to explicitly list the type of the variable,
as then the initializer is not required.
$BU0041
Similar to strings, multi-line comments must be terminated at some point. If
they are not, this error is raised.

For example:

```
/*
My comment text
*/ // The comment is terminated, allowed

/*
My comment text
// The comment is never terminated, not allowed
```

Note that comments using `//` are single-line, and are terminated automatically
at the end of the line.

Note that it is almost impossible to miss this syntax error with syntax highlighting, as
it would render the entire source file as a comment.
$BU0042
In Belte, you can have the compiler guess the type of a variable by replacing
any type with the `var` keyword. (Note: this only applies to variables, not
parameters, return types, etc.) Because the compiler uses the declaration
initializer to guess the variable type, it is required to have an initializer
when using the `var` keyword.

If the initializer is missing completely, error BU0040 is raised. If the
initializer is the `null` keyword, this error is raised. This is because
initializing an implicitly typed variable with `null` faces the same problem as
no initializer completely, as `null` is not specific to a single type.

For example:

```
var myInt = 3; // The compiler can figure out that `myInt` is an integer by the initializer, allowed
var myString = null; // Even though it is initialized, the compiler still has nothing to base the type on, not allowed
```

The only solution to this error is to explicitly list the type of the variable,
as then the initializer is not required at all, so `null` can be used to
initialize it.

Note that a variable successfully declared without an initializer defaults to
`null`:

```
int myInt;
// Is the same as
int myInt = null;
```
$BU0043
In Belte, you can have the compiler guess the type of a variable by replacing
any type with the `var` keyword. (Note: this only applies to variables, not
parameters, return types, etc.) Because the compiler uses the declaration
initializer to guess the variable type, it is required to have an initializer
when using the `var` keyword.

If the initializer is missing completely, error BU0040 is raised. If the
initializer is an empty initializer list (such as `{}`), this error is raised.
This is because initializing an implicitly typed variable with `{}` faces the
same problem as no initializer completely, as `{}` is not specific to a single
type.

For example:

```
var myCollection = {1, 2, 3}; // The compiler can figure out that `myCollection` is a collection of integers by the initializer, allowed
var myCollection = {}; // Even though it is initialized, the compiler still has nothing to base the type on, not allowed
```

In the given example, the compiler can not be sure what type of collection the
user is inferring. It could be `int[]`, `string[]`, or `bool[]` for all the
compiler knows.
$BU0044
Unlike C#, in Belte the `var` keyword does not only infer the base type name,
but instead, it infers the entire type, apart from the `const` keyword.

For example:

```
var[] myCollection = {1, 2, 3}; // Not allowed, as the compiler can infer the `[]` so it is not needed
var myCollection = {1, 2, 3}; // Allowed
```
$BU0045
The `var` keyword/implicit typing cannot be used in every context. Types
relating to a signature or field declarations need to be explicit as they never
have initializers, so the compiler would not know what types there are.

For example:

```
void MyFunction(var myParameter) { } // The compiler has no information on what the type of `myParameter` is, not allowed
```

Another example:

```
struct MyStruct {
    var myMember; // The compiler has no information on what the type of `myMember` is, not allowed
}
```

Implicit typing is only allowed for variable or constant declarations.
$BU0046
A try statement must have a catch or finally clause accompanying it. This is
because a try statement without a catch or finally would be no different then
a block statement, as the try block itself, does nothing, rather it is the catch
and finally clauses that handle the exceptions thrown.

For example:

```
try {
    int myVar = 5 / 0;
} // Not allowed, no catch or finally block

try {
    int myVar = 5 / 0;
} catch {
    PrintLine("DIVIDE BY ZERO");
} // Allowed

try {
    int myVar = 5 / 0;
} finally {
    PrintLine("Program is exiting");
} // Also allowed
```

Note that having both a catch and finally clause is also allowed.
$BU0047
If a call expression does not have an identifier as its operand, this error is
raised.

For example:

```
PrintLine(); // Allowed, `PrintLine` is an identifier and a function name
3(); // Not allowed, `3` is not an identifier
```

This is because all callable objects have identifiers, so if a call expression
has something other than an identifier as its operand, the compiler can
immediately tell it is a syntax error before any symbols are even resolved.
$BU0048
By-reference variables always reference other variables. Because of this, they
themselves cannot be null and require an initializer. If a by-reference
variable is declared with no initializer, this error is raised.

For example:

```
ref int myRef; // Incorrect, does not reference anything

int myVar = 3;
ref int myRef = ref myVar; // Correct, references `myVar`
```
$BU0049
By-reference variables can be assigned to with values, which are just passed on
to what it is referencing. However, the declaration initializer must be a
reference as there is nothing to pass on to yet. If a by-reference variable is
declared with a by-value initializer, this error is raised.

For example:

```
ref int myRef = 3; // Incorrect, `myRef` does not reference anything yet so it cannot pass `3` onto its reference

int myVar = 3;
ref int myRef = ref myVar; // Correct, references `myVar`; future by-value assignments are now allowed
```

Note that the reference must be explicit:

```
int myVar = 3;
ref int myRef = ref myVar;
ref int myOtherRef = myRef; // Not allowed, this would pass the value of `myVar` which is by-value, not by-reference
```
$BU0050
By-value variables cannot be assigned to by an explicit reference expressions.
They can be assigned to by variables that are references, and in that case, the
value that the by-reference variable is referencing is passed. If a by-value
variable is assigned to by an explicit reference expression, this error is
raised.

For example:

```
int myVar = 3;
int myOtherVar = ref myVar; // Incorrect, `myOtherVar` is by-value and cannot be assigned with a reference
```

Note that this only applies to explicit references, and a reference variable can
be the assignee:

```
int myVar = 3;
ref int myRef = ref myVar;
int myOtherVar = myRef; // Allowed, this would pass the value of `myVar` as that is what `myRef` is referencing
```
$BU0051
Attributes can be applied to types, and users can define their own attributes.
However, if the compiler is unaware of an attribute, this error is raised.

For example:

```
[NotNull]var myInt = 3; // Allowed, `NotNull` is a known attribute
[FakeAttrib]var myInt = 3; // Not allowed, `FakeAttrib` is not a known attribute
```
$BU0052
Some types are non-nullable, even though the default is nullable. If a variable
or constant is non-nullable, it cannot be assigned with `null`. If this is
attempted, this error is raised.

For example:

```
[NotNull]int myVar = null; // Not allowed, `myVar` is non-nullable, so it cannot be assigned to with `null`
```
$BU0053
Unlike C#, in Belte the `var` keyword does not only infer the base type name,
but instead, it infers the entire type, apart from the `const` keyword.

For example:

```
int myInt = 3;
ref var myRef = ref myInt; // Not allowed, as the compiler can infer the `ref` keyword so it is not needed
var myRef = ref myInt; // Allowed
```
$BU0054
By-reference variables can either be referencing a constant or a variable. These
are not interchangeable.

For example:

```
const int myConst = 3;
ref int myRef = ref myConst; // Not allowed, as `myRef` expects a reference to a variable, not a reference to a constant
```

This is an error because if this were allowed, constants could be modified
indirectly through references at runtime. This makes constants not different
than variables.

To highlight this point more clearly, take the example:

```
const int myConst = 3;
ref int myRef = ref myConst;
myRef = 4; // `myConst` is indirectly modified, now equalling `4`
```

The following is allowed:

```
const int myConst = 3;
ref const int myRef = ref myConst;
```

`myRef` can be assigned to, to change what it is referencing, but it cannot
change the value of what it is referencing at any time.

The following could be used if a variable reference is wanted:

```
int myInt = 3;
ref int myRef = ref myInt;
```
$BU0055
Void is used to denote that a function is a procedure. If void is used in most
other scenarios, the compiler produces this error. This is because `void` is NOT
a type, but rather an indicator that nothing will be returned.

For example:

```
void MyFunction() { } // Allowed

void myVar; // Not allowed, `void` cannot be used as a type
```
#BU0056
If a specific type of syntax is expected in an expression or statement, many
errors could be raised, depending on what gives the most information in any
context. If an incorrect piece of syntax is found, errors such as BU0006 will be
raised, but if a piece of syntax is purely missing, this error is raised.

For example:

```
struct { // An identifier is expected before the opening curly brace to identify the struct
    int myMember;
}
```

Another example:

```
void () { } // An identifier is expected before the opening parenthesis to identify the function
```
$BU0057
Error BU0029 is used if a function call has the wrong number of arguments. This
error is raised in place of that one if the function being called has overloads.

For example:

```
void MyFunction(int a) { }

void MyFunction(string a) { }

MyFunction(1, 3); // No overload matches this parameter list, incorrect
```

The reason the error is different is that the argument count can be correct,
but the types can be incorrect. A casting error cannot be raised because since
there are overloads, the compiler cannot tell the exact casting errors.
$BU0058
Sometimes a function call can be ambiguous between multiple overloads,
especially when the arguments are `null`. If the compiler cannot tell which
overload to use in a call expression, this error is raised.

For example:

```
void MyFunction(int a) { }

void MyFunction(string a) { }

MyFunction(null); // Ambiguous which overload is being inferred, as `null` could be either an integer or string
```
$BU0059
Increment and decrement expressions modify the operand. Because this is the
case, the operand must be modifiable/assignable. If it is attempted to
increment or decrement a nonassignable operand this error is raised.

For example:

```
1++; // Now allowed, `1` is not an assignable operand
int a = 3;
a++; // Allowed, `a` is assignable
```

This also applies to the prefix version of these operators:

```
++1; // Now allowed, `1` is not an assignable operand
int a = 3;
++a; // Allowed, `a` is assignable
```

And also applies to their decrement counterparts.

Only variables, fields, and indexers can be assigned to.
$BU0060
When a ternary operator is used with unsupported types, this error is produced.

For example:

```
int myInt = true ? 3 : 4; // `?:` is allowed with one boolean and two integers
bool myBool = 3 ? true : false; // But not with an integer and two booleans
```

A possible fix to this error may be inserting a cast.
$BU0061
When a nonexistent member is attempted to be accessed with a member access
expression, this error is raised.

For example:

```
int myInt = 3;
bool myBool = myInt.IsGreaterThanFour; // `IsGreaterThanFour` is not a member of the `int` type
```

Another example:

```
struct MyStruct {
    int myMember;
}

MyStruct myStruct = MyStruct();
int myInt = myStruct.myOtherMember; // `myOtherMember` is not a member of the user-defined `MyStruct` type
```

A full list of all the members of built-in types can be found in the Belte docs.
$BU0062
Not every expression can be assigned to. If an assignment expression is
attempted where the left side cannot be assigned to, this error is raised.

For example:

```
5 = 4; // You cannot assign to literal expressions
PrintLine() = 4; // You cannot assign to call expressions
```

You can only assign to variables, fields, and indexers. Any other left side
expression will result in this error.

Note that if the failure to assign is because the left side is a constant,
BU0022 is raised instead.
$BU0063
Nested/inner functions cannot be overloaded. If it is attempted to overload
a nested function, this error is raised.

For example:

```
void MyFunction() {
    void MyNestedFunction() { }

    void MyNestedFunction(int myParameter) { } // Overloads are not allowed, so this is seen as a duplicate definition which is not allowed
}
```

If you need to overload a nested function, you should probably be using methods
anyway.
$BU0064
By-reference variables can either be referencing a constant or a variable. These
are not interchangeable.

For example:

```
int myInt = 3;
ref const int myRef = ref myInt; // Not allowed, as `myRef` expects a reference to a constant, not a reference to a variable
```

This is an error because if this were allowed, code using the reference would
be under the false assumption that the value will not change. The value could
change indirectly if the variable the by-reference variable is referencing
changes during runtime.

To highlight this point more clearly, take the example:

```
int myInt = 3;
ref const int myRef = ref myInt;
myInt = 4; // `myInt` is modified, indirectly modifying `myRef` to be referencing a changed value
```

The following is allowed:

```
const int myConst = 3;
ref const int myRef = ref myConst;
```

`myRef` can be assigned to, to change what it is referencing, but it cannot
change the value of what it is referencing at any time.

The following could be used if a variable reference is wanted:

```
int myInt = 3;
ref int myRef = ref myInt;
```
$BU0065
When a prefix operator is used with unsupported types, this error is produced.

For example:

```
int myInt = 2;
++myInt; // '++' is allowed with integer types

bool myBool = false;
++myBool; // But not for decimal types
```

A possible fix to this error may be inserting a cast.
$BU0066
When a postfix operator is used with unsupported types, this error is produced.

For example:

```
int myInt = 2;
myInt++; // '++' is allowed with integer types

bool myBool = false;
myBool++; // But not for decimal types
```

A possible fix to this error may be inserting a cast.
$BU9000
Inside a global scope without a `Main` function, the compiler will run the
file top-down instead. Return statements are allowed in this case, however, it
is currently unsupported to return a value in this case.

For example:

```
if (2 == 2)
    return; // This is allowed
else
    return 3; // This is not allowed
```
$BU9001
Assembling natively is currently unsupported. If it is requested to assemble
natively, the compilation will not raise an error but rather ignore the request.

Compiling with .NET integration is the priority, so compiling natively will
likely be unsupported for many versions.
$BU9002
Linking natively is currently unsupported. If it is requested to link natively,
the compilation will not raise an error but rather ignore the request.

Compiling with .NET integration is the priority, so compiling natively will
likely be unsupported for many versions.
$BU9003
Compiling natively is currently unsupported. If it is requested to compile
natively, this error is raised.

Compiling with .NET integration is the priority, so compiling natively will
likely be unsupported for many versions.
$BU9004
Structure fields cannot be initialized when they are declared in the structure
declaration. This may be changed in a future version, but currently if it is
attempted this error is raised.

For example:

```
struct MyStruct {
    int myMember = 3; // Not allowed currently
}
```