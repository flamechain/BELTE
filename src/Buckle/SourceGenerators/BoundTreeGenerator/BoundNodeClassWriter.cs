using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace BoundTreeGenerator;


/// <summary>
/// Handles writing the bound node classes source file.
/// </summary>
internal sealed partial class BoundNodeClassWriter {
    private readonly TextWriter _writer;
    private readonly IDictionary<string, string> _parentMap;
    private HashSet<string> _valueTypes;

    private const int IndentSize = 4;
    private int _indentLevel;
    private bool _needIndent = true;

    /// <summary>
    /// Creates a new <see cref="BoundNodeClassWriter" /> with a deserialized XML tree representation of the
    /// syntax XML file.
    /// </summary>
    internal BoundNodeClassWriter(TextWriter writer, Tree tree) {
        _writer = writer;
        _tree = tree;
        _parentMap = tree.types.ToDictionary(n => n.Name, n => n.Base);
        _parentMap.Add(tree.Root, null);
        InitializeValueTypes();
    }

    private Tree _tree { get; }

    public static void Write(TextWriter writer, Tree tree) => new BoundNodeClassWriter(writer, tree).WriteFile();

    private void InitializeValueTypes() {
        _valueTypes = [];

        foreach (var t in _tree.types.Where(t => t is ValueType).Cast<ValueType>())
            _valueTypes.Add(t.Name);

        _valueTypes.Add("bool");
        _valueTypes.Add("int");
        _valueTypes.Add("char");
        _valueTypes.Add("ImmutableArray");
        _valueTypes.Add("TypeWithAnnotations");
        _valueTypes.Add("BitVector");
    }

    private void WriteFile() {
        WriteFileHeader();
        WriteLine("namespace Buckle.CodeAnalysis.Binding;");
        WriteLine();

        WriteBoundKindEnum();
        WriteNodes();
        WriteVisitor();
        WriteRewriter();
    }

    private void WriteFileHeader() {
        WriteLine("// <auto-generated/>");
        WriteLine();
        WriteUsing("System.Collections.Immutable");
        WriteUsing("System.Diagnostics");
        WriteUsing("System.Runtime.CompilerServices");
        WriteUsing("Buckle.CodeAnalysis.Symbols");
        WriteUsing("Buckle.CodeAnalysis.Syntax");
        WriteUsing("Buckle.Diagnostics");
        WriteLine();
    }

    private void Write(string msg) {
        WriteIndentIfNeeded();
        _writer.Write(msg);
    }

    private void WriteLine() {
        _writer.WriteLine();
        _needIndent = true;
    }

    private void WriteLine(string msg) {
        if (msg != "")
            WriteIndentIfNeeded();

        _writer.WriteLine(msg);
        _needIndent = true;
    }

    private void WriteIndentIfNeeded() {
        if (_needIndent) {
            _writer.Write(new string(' ', _indentLevel * IndentSize));
            _needIndent = false;
        }
    }

    private void OpenBlock() {
        WriteLine(" {");
        Indent();
    }

    private void CloseBlock(string extra = "") {
        Unindent();
        WriteLine("}" + extra);
    }

    private void Indent() {
        _indentLevel++;
    }

    private void Unindent() {
        if (_indentLevel <= 0)
            throw new InvalidOperationException("Cannot unindent from base level");

        _indentLevel--;
    }

    private static bool SkipInVisitor(Field f) {
        return string.Compare(f.SkipInVisitor, "true", true) == 0
            || VisitFieldOnlyInNullabilityRewriter(f);
    }

    private static bool VisitFieldOnlyInNullabilityRewriter(Field f) {
        return string.Compare(f.SkipInVisitor, "ExceptNullabilityRewriter", true) == 0;
    }

    private void WriteUsing(string namespaceName) {
        WriteLine($"using {namespaceName};");
    }

    private static bool TypeIsTypeSymbol(Field field) => field.Type.TrimEnd('?') == "TypeSymbol";

    private static bool TypeIsSymbol(Field field) => TypeIsSymbol(field.Type);

    private static bool TypeIsSymbol(string type) => type.TrimEnd('?').EndsWith("Symbol");

    private string StripBound(string name) {
        if (name.StartsWith("Bound", StringComparison.Ordinal))
            name = name.Substring(5);

        return name;
    }

    private string StripNull(string type) {
        if (type.EndsWith('?') && !IsValueType(type))
            type = type.Substring(0, type.Length - 1);

        return type;
    }

    private void ParenList<T>(IEnumerable<T> items, Func<T, string> func) {
        Paren();
        Comma(items, func);
        UnParen();
    }

    private void ParenList(IEnumerable<string> items) {
        Paren();
        Comma(items, x => x);
        UnParen();
    }

    private void Paren() {
        Write("(");
    }

    private void UnParen() {
        Write(")");
    }

    private IEnumerable<Field> AllTypeFields(TreeType node) {
        return AllFields(node).Where(TypeIsTypeSymbol);
    }

    private void SeparatedList<T>(string separator, IEnumerable<T> items, Func<T, string> func) {
        var first = true;

        foreach (var item in items) {
            if (!first)
                _writer.Write(separator);

            first = false;
            _writer.Write(func(item));
        }
    }

    private void Comma<T>(IEnumerable<T> items, Func<T, string> func) {
        SeparatedList(", ", items, func);
    }

    private TreeType BaseType(TreeType node) {
        var name = _parentMap[node.Name];

        if (name == _tree.Root)
            return null;

        return _tree.types.Single(t => t.Name == name);
    }

    private static IEnumerable<Field> Fields(TreeType node) {
        if (node is AbstractNode aNode)
            return from n in aNode.Fields where !n.Override select n;

        return [];
    }

    private IEnumerable<TreeType> TypeAndBaseTypes(TreeType node) {
        var n = node;

        while (n is not null) {
            yield return n;
            n = BaseType(n);
        }
    }

    private IEnumerable<Field> AllFields(TreeType node) {
        if (node is null)
            return [];

        return from t in TypeAndBaseTypes(node)
               from f in Fields(t)
               select f;
    }

    private static IEnumerable<Field> FieldsIncludingOverrides(TreeType node) {
        if (node is AbstractNode aNode)
            return aNode.Fields;

        return [];
    }

    private Field GetField(TreeType node, string fieldName) {
        var fieldsWithName = from f in FieldsIncludingOverrides(node) where f.Name == fieldName select f;

        if (fieldsWithName.Any())
            return fieldsWithName.Single();
        else if (BaseType(node) != null)
            return GetField(BaseType(node), fieldName);
        else
            throw new InvalidOperationException($"Field {fieldName} not found in type {node.Name}");
    }

    private string ToCamelCase(string name) {
        if (char.IsUpper(name[0]))
            name = char.ToLowerInvariant(name[0]) + name.Substring(1);

        return name;
    }

    private bool IsListOfDerived(string baseType, string derivedType) {
        return IsNodeList(derivedType) && IsDerivedType(baseType, GetElementType(derivedType));
    }

    private bool IsNodeList(string typeName) {
        return typeName.StartsWith("IList<", StringComparison.Ordinal) ||
               typeName.StartsWith("ImmutableArray<", StringComparison.Ordinal);
    }

    private bool CanBeSealed(TreeType node) {
        return !_parentMap.Values.Contains(node.Name);
    }

    private string GetElementType(string typeName) {
        if (!typeName.Contains('<'))
            return "";

        var iStart = typeName.IndexOf('<');
        var iEnd = typeName.IndexOf('>', iStart + 1);

        if (iEnd < iStart)
            return "";

        var sub = typeName.Substring(iStart + 1, iEnd - iStart - 1);
        return sub;
    }

    private bool IsDerivedType(string typeName, string derivedTypeName) {
        typeName = typeName.TrimEnd('?');
        derivedTypeName = derivedTypeName?.TrimEnd('?');

        if (typeName == derivedTypeName)
            return true;

        if (derivedTypeName != null && _parentMap.TryGetValue(derivedTypeName, out var baseType))
            return IsDerivedType(typeName, baseType);

        return false;
    }

    private bool IsDerivedOrListOfDerived(string baseType, string derivedType) {
        return IsDerivedType(baseType, derivedType) || IsListOfDerived(baseType, derivedType);
    }

    private IEnumerable<Field> AllNodeOrNodeListFields(TreeType node) {
        return AllFields(node).Where(field => IsDerivedOrListOfDerived("BoundNode", field.Type));
    }

    private IEnumerable<Field> AllSpecifiableFields(TreeType node) {
        return from f in AllFields(node) where FieldNullHandling(node, f.Name) != NullHandling.Always select f;
    }

    private void Or<T>(IEnumerable<T> items, Func<T, string> func) {
        SeparatedList(" || ", items, func);
    }

    private static bool IsPropertyOverrides(Field f) {
        return string.Compare(f.PropertyOverrides, "true", true) == 0;
    }

    private static bool IsNew(Field f) {
        return string.Compare(f.New, "true", true) == 0;
    }

    private bool IsValueType(string typeName) => _valueTypes.Contains(GetTemplateType(typeName).TrimEnd('?'));

    private string GetTemplateType(string typeName) {
        if (!typeName.Contains('<'))
            return typeName;

        var iStart = typeName.IndexOf('<');
        return typeName.Substring(0, iStart);
    }

    private NullHandling FieldNullHandling(TreeType node, string fieldName) {
        var f = GetField(node, fieldName);

        if (f.Null is not null) {
            if ((f.Null.ToUpperInvariant() is "ALLOW" or "ALWAYS") && !f.Type.EndsWith('?') && !IsValueType(f.Type)) {
                throw new ArgumentException($"Field '{fieldName}' on node '{node.Name}' should have a nullable type, " +
                    "since it isn't a value type and it is marked null=allow or null=always");
            }

            switch (f.Null.ToUpperInvariant()) {
                case "ALLOW":
                    return NullHandling.Allow;
                case "DISALLOW":
                    return NullHandling.Disallow;
                case "ALWAYS":
                    return NullHandling.Always;
                case "NOTAPPLICABLE":
                    return NullHandling.NotApplicable;
                case "":
                    break;
                default:
                    throw new ArgumentException("Unexpected value", nameof(f.Null));
            }
        }

        if (f.Type.EndsWith('?'))
            return NullHandling.Allow;

        if (f.Override)
            return FieldNullHandling(BaseType(node), fieldName);
        else if (!IsValueType(f.Type) || GetTemplateType(f.Type) == "ImmutableArray")
            return NullHandling.Disallow;
        else
            return NullHandling.NotApplicable;
    }

    private void WriteBoundKindEnum() {
        Write("internal enum BoundKind : byte");
        OpenBlock();

        foreach (var node in _tree.types.OfType<Node>())
            WriteLine($"{StripBound(node.Name)},");

        CloseBlock();
    }

    private void WriteNodes() {
        foreach (var node in _tree.types.Where(n => n is not PredefinedNode and AbstractNode)) {
            WriteLine();
            WriteNode(node);
        }
    }

    private void WriteNode(TreeType node) {
        WriteClassHeader(node);

        var unsealed = !CanBeSealed(node);
        var concrete = node is Node;
        var hasChildNodes = AllNodeOrNodeListFields(node).Any();

        if (unsealed)
            WriteConstructor(node, isConcrete: false, hasChildNodes);

        if (concrete)
            WriteConstructor(node, isConcrete: true, hasChildNodes);

        foreach (var field in FieldsIncludingOverrides(node)) {
            WriteField(node, field);
            WriteLine();
        }

        if (node is Node) {
            WriteAccept(node.Name);
            WriteUpdate(node as Node);
        }

        CloseBlock();
    }

    private void WriteAccept(string name) {
        WriteLine("[DebuggerStepThrough]");
        WriteLine($"internal override BoundNode Accept(BoundTreeVisitor visitor) => visitor.Visit{StripBound(name)}(this);");
    }

    private void WriteUpdate(Node node) {
        if (!AllFields(node).Any())
            return;

        var emitNew = (!Fields(node).Any()) && BaseType(node) is Node;

        WriteLine();
        Write($"internal{(emitNew ? " new" : "")} {node.Name} Update");
        Paren();
        Comma(AllSpecifiableFields(node), field => string.Format("{0} {1}", StripNull(GetField(node, field.Name).Type), ToCamelCase(field.Name)));
        UnParen();
        OpenBlock();

        if (AllSpecifiableFields(node).Any()) {
            Write("if ");
            Paren();
            Or(AllSpecifiableFields(node), NotEquals);
            UnParen();
            OpenBlock();
            Write($"return new {node.Name}");
            var fields = new[] { "this.syntax" }.Concat(AllSpecifiableFields(node).Select(f => ToCamelCase(f.Name))).Concat(["this.HasErrors()"]);
            ParenList(fields);
            WriteLine(";");
            CloseBlock();
        }

        WriteLine();
        WriteLine("return this;");
        CloseBlock();

        string NotEquals(Field field) {
            var parameterName = ToCamelCase(field.Name);
            var fieldName = field.Name;

            if (TypeIsTypeSymbol(field))
                return $"!TypeSymbol.Equals({parameterName}, this.{fieldName}, TypeCompareKind.ConsiderEverything)";

            if (TypeIsSymbol(field))
                return $"!Symbols.SymbolEqualityComparer.ConsiderEverything.Equals({parameterName}, this.{fieldName})";

            if (IsValueType(field.Type) && field.Type[^1] == '?')
                return $"!{parameterName}.Equals(this.{fieldName})";

            if (GetTemplateType(field.Type) == "OneOrMany")
                return $"!{parameterName}.SequenceEqual({fieldName})";

            return $"{parameterName} != this.{fieldName}";
        }
    }

    private void WriteClassHeader(TreeType node) {
        var abstr = "";

        if (node is AbstractNode and not Node)
            abstr = "abstract ";

        else if (CanBeSealed(node))
            abstr = "sealed ";

        Write($"internal {abstr}partial class {node.Name} : {node.Base}");
        OpenBlock();
    }

    private void WriteConstructor(TreeType node, bool isConcrete, bool hasChildNodes) {
        if (hasChildNodes) {
            WriteConstructorWithHasErrors(node, isConcrete, hasErrorsIsOptional: true);
        } else {
            WriteConstructorWithHasErrors(node, isConcrete, hasErrorsIsOptional: false);
            WriteConstructorWithoutHasErrors(node, isConcrete);
        }
    }

    private void WriteConstructorWithoutHasErrors(TreeType node, bool isConcrete) {
        Write($"{(isConcrete ? "internal" : "private protected")} {node.Name}");
        IEnumerable<string> fields = isConcrete ? ["SyntaxNode syntax"] : ["BoundKind kind", "SyntaxNode syntax"];
        fields = fields.Concat(from field in AllSpecifiableFields(node)
                               let mostSpecific = GetField(node, field.Name)
                               select StripNull(mostSpecific.Type) + " " + ToCamelCase(field.Name));

        ParenList(fields, x => x);
        WriteLine();
        Write("  : base(");

        if (isConcrete) {
            Write($"BoundKind.{StripBound(node.Name)}, syntax");

            foreach (var baseField in AllSpecifiableFields(BaseType(node)))
                Write($", {(FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name))}");
        } else {
            Write("kind, syntax");

            foreach (var baseField in AllSpecifiableFields(BaseType(node)))
                Write($", {(FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name))}");
        }

        Write(")");
        OpenBlock();

        WriteNullChecks(node);

        foreach (var field in Fields(node))
            WriteLine($"this.{field.Name} = {(FieldNullHandling(node, field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name))};");

        CloseBlock();
        WriteLine();
    }

    private void WriteConstructorWithHasErrors(TreeType node, bool isConcrete, bool hasErrorsIsOptional) {
        Write($"{(isConcrete ? "internal" : "private protected")} {node.Name}");
        IEnumerable<string> fields = isConcrete ? ["SyntaxNode syntax"] : ["BoundKind kind", "SyntaxNode syntax"];

        fields = fields.Concat(from field in AllSpecifiableFields(node)
                               let mostSpecific = GetField(node, field.Name)
                               select StripNull(mostSpecific.Type) + " " + ToCamelCase(field.Name));

        if (hasErrorsIsOptional)
            fields = fields.Concat(["bool hasErrors = false"]);
        else
            fields = fields.Concat(["bool hasErrors"]);

        ParenList(fields, x => x);
        WriteLine();
        Write("  : base(");

        if (isConcrete) {
            Write($"BoundKind.{StripBound(node.Name)}, syntax, ");

            foreach (var baseField in AllSpecifiableFields(BaseType(node)))
                Write($"{(FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name))}, ");

            Or((new[] { "hasErrors" })
                .Concat(from field in AllNodeOrNodeListFields(node)
                        select ToCamelCase(field.Name) + ".HasErrors()"), x => x);
        } else {
            Write("kind, syntax, ");

            foreach (var baseField in AllSpecifiableFields(BaseType(node)))
                Write($"{(FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name))}, ");

            Write("hasErrors");
        }

        Write(")");
        OpenBlock();

        WriteNullChecks(node);

        foreach (var field in Fields(node))
            WriteLine($"this.{field.Name} = {(FieldNullHandling(node, field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name))};");

        CloseBlock();
        WriteLine();
    }

    private void WriteNullChecks(TreeType node) {
        var nullCheckFields = AllFields(node).Where(f => FieldNullHandling(node, f.Name) == NullHandling.Disallow);

        if (nullCheckFields.Any()) {
            WriteLine();

            foreach (var field in nullCheckFields) {
                var useIsDefaultProperty = GetTemplateType(field.Type) is "ImmutableArray" or "OneOrMany";

                if (useIsDefaultProperty)
                    WriteLine($"Debug.Assert(!{ToCamelCase(field.Name)}.IsDefault, \"Field '{ToCamelCase(field.Name)}' cannot be null (use Null=\\\"allow\\\" in BoundNodes.xml to remove this check)\");");
                else
                    WriteLine($"Debug.Assert({ToCamelCase(field.Name)} is object, \"Field '{ToCamelCase(field.Name)}' cannot be null (make the type nullable in BoundNodes.xml to remove this check)\");");
            }

            WriteLine();
        }
    }

    private void WriteField(TreeType node, Field field) {
        if (IsPropertyOverrides(field)) {
            WriteLine($"internal override {(IsNew(field) ? "new " : "")}{StripNull(field.Type)} {field.Name} {{ get; }}");
        } else if (field.Override) {
            // var suppression = FieldNullHandling(node, field.Name) is NullHandling.Allow or NullHandling.Always ? "" : "!";
            var suppression = "";
            WriteLine($"internal new {StripNull(field.Type)} {field.Name} => base.{field.Name}{suppression};");
        } else {
            WriteLine($"internal {(IsNew(field) ? "new " : "")}{StripNull(field.Type)} {field.Name} {{ get; }}");
        }
    }

    private void WriteVisitor() {
        WriteLine();
        Write("internal abstract partial class BoundTreeVisitor<A, R>");
        OpenBlock();
        WriteLine("[MethodImpl(MethodImplOptions.NoInlining), DebuggerStepThrough]");
        Write("internal R VisitInternal(BoundNode node, A arg)");
        OpenBlock();

        WriteLine("switch (node.kind)");
        OpenBlock();

        foreach (var node in _tree.types.OfType<Node>()) {
            WriteLine($"case BoundKind.{StripBound(node.Name)}:");
            Indent();
            WriteLine($"return Visit{StripBound(node.Name)}(({node.Name})node, arg);");
            Unindent();
        }

        CloseBlock();
        WriteLine();
        WriteLine("return default(R)!;");
        CloseBlock();
        CloseBlock();

        WriteLine();
        Write("internal abstract partial class BoundTreeVisitor<A, R>");
        OpenBlock();

        foreach (var node in _tree.types.OfType<Node>())
            WriteLine($"internal virtual R Visit{StripBound(node.Name)}({node.Name} node, A arg) => this.DefaultVisit(node, arg);");

        CloseBlock();

        WriteLine();
        Write("internal abstract partial class BoundTreeVisitor");
        OpenBlock();

        foreach (var node in _tree.types.OfType<Node>())
            WriteLine($"internal virtual BoundNode Visit{StripBound(node.Name)}({node.Name} node) => this.DefaultVisit(node);");

        CloseBlock();
    }

    private void WriteRewriter() {
        WriteLine();
        Write("internal abstract partial class BoundTreeRewriter : BoundTreeVisitor");
        OpenBlock();

        foreach (var node in _tree.types.OfType<Node>()) {
            if (!AllNodeOrNodeListFields(node).Any() && !AllTypeFields(node).Any()) {
                WriteLine($"{GetVisitFunctionDeclaration(node.Name, isOverride: true)} => node;");
                continue;
            }

            Write(GetVisitFunctionDeclaration(node.Name, isOverride: true));
            OpenBlock();
            var hadField = false;

            foreach (var field in AllNodeOrNodeListFields(node)) {
                hadField = true;
                WriteNodeVisitCall(field);
            }

            foreach (var field in AllTypeFields(node)) {
                hadField = true;
                WriteLine($"TypeSymbol {ToCamelCase(field.Name)} = this.VisitType(node.{field.Name});");
            }

            if (hadField) {
                Write("return node.Update");
                ParenList(AllSpecifiableFields(node), field => IsDerivedOrListOfDerived("BoundNode", StripNull(field.Type)) || TypeIsTypeSymbol(field) ? ToCamelCase(field.Name) : string.Format("node.{0}", field.Name));
                WriteLine(";");
            } else {
                WriteLine("return node;");
            }

            CloseBlock();
            WriteLine();
        }

        CloseBlock();
    }

    private void WriteNodeVisitCall(Field field, bool forceVisit = false) {
        if (SkipInVisitor(field) && !forceVisit)
            WriteLine($"{StripNull(field.Type)} {ToCamelCase(field.Name)} = node.{field.Name};");
        else if (IsNodeList(field.Type))
            WriteLine($"{field.Type} {ToCamelCase(field.Name)} = this.VisitList(node.{field.Name});");
        else
            WriteLine($"{StripNull(field.Type)} {ToCamelCase(field.Name)} = ({StripNull(field.Type)})this.Visit(node.{field.Name});");
    }

    private string GetVisitFunctionDeclaration(string name, bool isOverride) {
        return $"internal {(isOverride ? "override" : "virtual")} BoundNode Visit{StripBound(name)}({name} node)";
    }
}
