using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace Buckle.Generators;

internal sealed class SourceWriter {
    private readonly TextWriter _writer;
    private readonly Tree _tree;
    private readonly IDictionary<string, string> _parentMap;
    private readonly ILookup<string, string> _childMap;

    private readonly IDictionary<string, Node> _nodeMap;
    private readonly IDictionary<string, TreeType> _typeMap;

    private const int IndentSize = 4;
    private int _indentLevel;
    private bool _needIndent = true;

    internal SourceWriter(TextWriter writer, Tree tree) {
        _writer = writer;
        _tree = tree;
        _nodeMap = tree.types.OfType<Node>().ToDictionary(n => n.name);
        _typeMap = tree.types.ToDictionary(n => n.name);
        _parentMap = tree.types.ToDictionary(n => n.name, n => n.@base);
        _parentMap.Add(tree.root, null);
        _childMap = tree.types.ToLookup(n => n.@base, n => n.name);
    }

    private IDictionary<string, string> parentMap { get { return _parentMap; } }
    private ILookup<string, string> childMap { get { return _childMap; } }
    private Tree tree { get { return _tree; } }

    public static void WriteInternal(TextWriter writer, Tree tree) => new SourceWriter(writer, tree).WriteInternal();

    public static void WriteSyntax(TextWriter writer, Tree tree) => new SourceWriter(writer, tree).WriteSyntax();

    private static bool IsSeparatedNodeList(string typeName) {
        return typeName.StartsWith("SeparatedSyntaxList<", StringComparison.Ordinal);
    }

    private static bool IsNodeList(string typeName) {
        return typeName.StartsWith("SyntaxList<", StringComparison.Ordinal);
    }

    private static bool IsAnyNodeList(string typeName) {
        return IsNodeList(typeName) || IsSeparatedNodeList(typeName);
    }

    private void Indent() {
        _indentLevel++;
    }

    private void Unindent() {
        if (_indentLevel <= 0)
            throw new InvalidOperationException("Cannot unindent from base level");

        _indentLevel--;
    }

    private void Write(string msg) {
        WriteIndentIfNeeded();
        _writer.Write(msg);
    }

    private void WriteLine() {
        WriteLine("");
    }

    private void WriteLine(string msg) {
        if (msg != "")
            WriteIndentIfNeeded();

        _writer.WriteLine(msg);
        _needIndent = true;
    }

    private void WriteLineWithoutIndent(string msg) {
        _writer.WriteLine(msg);
        _needIndent = true;
    }

    private void WriteIndentIfNeeded() {
        if (_needIndent) {
            _writer.Write(new string(' ', _indentLevel * IndentSize));
            _needIndent = false;
        }
    }

    private string CommaJoin(params object[] values) => Join(", ", values);

    private string Join(string separator, params object[] values)
        => string.Join(separator, values.SelectMany(v => (v switch {
            string s => new[] { s },
            IEnumerable<string> ss => ss,
            _ => throw new InvalidOperationException("Join must be passed strings or collections of strings")
        }).Where(s => s != "")));

    private void OpenBlock() {
        WriteLine("{");
        Indent();
    }

    private void CloseBlock(string extra = "") {
        Unindent();
        WriteLine("}" + extra);
    }

    private bool IsNode(string typeName) {
        return _parentMap.ContainsKey(typeName);
    }

    private bool IsNodeOrNodeList(string typeName) {
        return IsNode(typeName) || IsNodeList(typeName) || IsSeparatedNodeList(typeName) || typeName == "SyntaxNodeOrTokenList";
    }

    private void WriteInternal() {
        WriteFileHeader();
        WriteLine("namespace Buckle.CodeAnalysis.Syntax.InternalSyntax;");
        WriteLine();

        WriteGreenNodes();
        WriteGreenVisitorT();
        WriteGreenVisitor();
        WriteGreenRewriter();
        WriteGreenFactory();
    }

    private void WriteSyntax() {
        WriteFileHeader();
        WriteLine("namespace Buckle.CodeAnalysis.Syntax;");
        WriteLine();

        WriteRedNodes();
        WriteRedFactory();
    }

    private void WriteFileHeader() {
        WriteLine("// <auto-generated/>");
        WriteLine();
        WriteLine("using System.Diagnostics;");
        WriteLine("using Buckle.CodeAnalysis.Syntax.InternalSyntax;");
        WriteLine("using Diagnostics;");
        WriteLine();
    }

    private void WriteGreenNodes() {
        var nodes = tree.types.Where(n => n is not PredefinedNode).ToList();

        foreach (var node in nodes) {
            WriteLine();
            WriteGreenNode(node);
        }
    }

    private void WriteGreenNode(TreeType node) {
        if (node is AbstractNode) {

        } else if (node is Node) {

        }
    }

    private void WriteGreenVisitorT() {
        throw new NotImplementedException();
    }

    private void WriteGreenVisitor() {
        throw new NotImplementedException();
    }

    private void WriteGreenRewriter() {
        throw new NotImplementedException();
    }

    private void WriteGreenFactory() {
        throw new NotImplementedException();
    }

    private void WriteRedAbstractNodes() {
        throw new NotImplementedException();
    }

    private void WriteRedNodes() {
        var nodes = tree.types.Where(n => n is not PredefinedNode).ToList();

        foreach (var node in nodes) {
            WriteLine();
            WriteRedNode(node);
        }
    }

    private void WriteRedNode(TreeType node) {
        if (node is AbstractNode abstractNode) {
            var @base = node.@base == "SyntaxNode" ? "BelteSyntaxNode" : node.@base;

            Write($"public abstract class {node.name} : {@base} ");
            OpenBlock();
            WriteLine($"internal {node.name}(SyntaxNode parent, GreenNode green, int position)");
            WriteLine("  : base(parent, green, position) { }");
            OpenBlock();
            CloseBlock();

            var valueFields = abstractNode.fields.Where(n => !IsNodeOrNodeList(n.type)).ToList();
            var nodeFields = GetNodeOrNodeListFields(abstractNode);

            for (var field in node.fields)


                CloseBlock();

            //     var fields = DeserializeFields(abstractNode);
            //     GenerateFieldDeclarations(writer, fields, typeName, isAbstract: true);
            // }

            // writer.WriteLine();
        } else if (node is Node) {

        }
    }

    private void WriteRedFactory() {
        throw new NotImplementedException();
    }
}
